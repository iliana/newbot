// SPDX-License-Identifier: GPL-3.0-or-later

#![warn(clippy::pedantic)]

use std::collections::{BTreeMap, BTreeSet};
use std::convert::TryFrom;

const ZWJ: char = '\u{200d}';
static ROLES: [&str; 19] = [
    "\u{2695}\u{fe0f}",
    "\u{2696}\u{fe0f}",
    "\u{2708}\u{fe0f}",
    "\u{1f33e}",
    "\u{1f373}",
    "\u{1f393}",
    "\u{1f3a4}",
    "\u{1f3a8}",
    "\u{1f3eb}",
    "\u{1f3ed}",
    "\u{1f4bb}",
    "\u{1f4bc}",
    "\u{1f527}",
    "\u{1f52c}",
    "\u{1f680}",
    "\u{1f692}",
    "\u{1f9af}",
    "\u{1f9bc}",
    "\u{1f9bd}",
];

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum Classification {
    Base(char),
    Role(char),
    Independent(String),
    GeopoliticalFlag,
    Couple,
    Family,
    HoldingHands,
    Kiss,
    Duplicate,
}

fn main() {
    let dir = std::env::args_os().nth(1).unwrap_or_else(|| {
        eprintln!("usage: classify-twemoji TWEMOJI_ASSET_DIR");
        std::process::exit(1)
    });

    let mut map: BTreeMap<Classification, BTreeSet<String>> = BTreeMap::new();

    for entry in std::fs::read_dir(dir).unwrap() {
        let path = entry.unwrap().path();
        let emoji = emoji_from_file_name(path.file_name().unwrap().to_str().unwrap());
        let classification = classify(&emoji);
        if !(classification == Classification::Duplicate
            || classification == Classification::GeopoliticalFlag)
        {
            map.entry(classification).or_default().insert(emoji);
        }
    }

    // You are permitted to modify the license of the output of this program
    println!("// SPDX-License-Identifier: GPL-3.0-or-later");
    println!("// This module is automatically @generated by bin/classify-twemoji.rs");
    println!("#[rustfmt::skip]");
    println!("pub(crate) static EMOJI_SETS: &[&[&str]] = &[");
    for set in map.values() {
        if set.len() == 1 {
            for emoji in set {
                println!("    &[\"{}\"],", emoji.escape_unicode());
            }
        } else {
            println!("    &[");
            for emoji in set {
                println!("        \"{}\",", emoji.escape_unicode());
            }
            println!("    ],");
        }
    }
    println!("];");
}

fn emoji_from_file_name(file_name: &str) -> String {
    let mut emoji = file_name
        .split('.')
        .next()
        .unwrap()
        .split('-')
        .map(|fragment| char::try_from(u32::from_str_radix(fragment, 16).unwrap()).unwrap())
        .collect::<String>();
    if emoji.chars().count() == 1
        && emoji
            .chars()
            .all(|c| !unic_emoji_char::is_emoji_presentation(c))
    {
        emoji.push('\u{fe0f}');
    }
    emoji
}

fn classify(emoji: &str) -> Classification {
    if emoji.contains(ZWJ) {
        if let Some(role) = ROLES
            .iter()
            .find(|role| emoji.ends_with(&format!("{}{}", ZWJ, role)))
        {
            Classification::Role(role.chars().next().unwrap())
        } else if emoji
            .split(ZWJ)
            .all(|c| (0x1f466..=0x1f469).contains(&(c.chars().next().unwrap() as u32)))
        {
            Classification::Family
        } else if emoji.contains('\u{1f48b}') {
            Classification::Kiss
        } else if emoji.contains("\u{2764}\u{fe0f}") {
            Classification::Couple
        } else if emoji.contains('\u{1f91d}') {
            Classification::HoldingHands
        } else if is_emoji_modifier_base(emoji.chars().next().unwrap()) {
            Classification::Base(emoji.chars().next().unwrap())
        } else if ['\u{1f3f3}', '\u{1f3f4}'].contains(&emoji.chars().next().unwrap())
            || ["\u{1f415}\u{200d}\u{1f9ba}", "\u{1f441}\u{200d}\u{1f5e8}"].contains(&emoji)
        {
            Classification::Independent(emoji.to_owned())
        } else {
            panic!(
                "emoji {} {} contains ZWJ and wasn't classified",
                emoji,
                emoji.escape_unicode()
            );
        }
    } else if emoji == "\u{1f46a}" || emoji == "\u{1f48f}" || emoji == "\u{1f491}" {
        Classification::Duplicate
    } else if (0x1f46b..=0x1f46d).contains(&(emoji.chars().next().unwrap() as u32)) {
        Classification::HoldingHands
    } else if (emoji.chars().count() == 2
        && emoji
            .chars()
            .all(|c| (0x1f1e6..=0x1f1ff).contains(&(c as u32))))
        || emoji.contains('\u{e0067}')
    {
        Classification::GeopoliticalFlag
    } else {
        Classification::Base(emoji.chars().next().unwrap())
    }
}

fn is_emoji_modifier_base(c: char) -> bool {
    unic_emoji_char::is_emoji_modifier_base(c)
        || [
            '\u{1f46f}',
            '\u{1f93c}',
            '\u{1f9b8}',
            '\u{1f9b9}',
            '\u{1f9cd}',
            '\u{1f9ce}',
            '\u{1f9cf}',
            '\u{1f9de}',
            '\u{1f9df}',
        ]
        .contains(&c)
}
